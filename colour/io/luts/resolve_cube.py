# -*- coding: utf-8 -*-
"""
Resolve .cube LUT Format Input / Output Utilities
================================================

Defines *Resolve* *.cube* *LUT* Format related input / output utilities
objects.

-   :func:`colour.io.read_LUT_ResolveCube`
-   :func:`colour.io.write_LUT_ResolveCube`

References
----------
-   :cite:`Chamberlain2015` :ï»¿Chamberlain, P. (2015). LUT documentation
    (to create from another program). Retrieved August 23, 2018, from
    https://forum.blackmagicdesign.com/viewtopic.php?f=21&t=40284#p232952
"""

from __future__ import division, unicode_literals

import numpy as np
import os
import re

from colour.constants import DEFAULT_FLOAT_DTYPE
from colour.io.luts import LUT1D, LUT2D, LUT3D
from colour.utilities import tstack

__author__ = 'Colour Developers'
__copyright__ = 'Copyright (C) 2013-2018 - Colour Developers'
__license__ = 'New BSD License - http://opensource.org/licenses/BSD-3-Clause'
__maintainer__ = 'Colour Developers'
__email__ = 'colour-science@googlegroups.com'
__status__ = 'Production'

__all__ = ['read_LUT_ResolveCube', 'write_LUT_ResolveCube']


def read_LUT_ResolveCube(path):
    """
    Reads given *Resolve* *.cube* *LUT* file.

    Parameters
    ----------
    path : unicode
        *LUT* path.

    Returns
    -------
    LUT2D or LUT3D
        :class:`LUT2D` or :class:`LUT3D` class instance.

    References
    ----------
    :cite:`Chamberlain2015`

    Examples
    --------
    Reading a 2D *Resolve* *.cube* *LUT*:

    >>> path = os.path.join(
    ...     os.path.dirname(__file__), 'tests', 'resources', 'resolve_cube',
    ...     'ACES_Proxy_10_to_ACES.cube')
    >>> print(read_LUT_ResolveCube(path))
    LUT2D - ACES Proxy 10 to ACES
    -----------------------------
    <BLANKLINE>
    Dimensions : 2
    Domain     : [[0 0 0]
                  [1 1 1]]
    Size       : (32, 3)

    Reading a 3D *Resolve* *.cube* *LUT*:

    >>> path = os.path.join(
    ...     os.path.dirname(__file__), 'tests', 'resources', 'resolve_cube',
    ...     'ColourCorrect.cube')
    >>> print(read_LUT_ResolveCube(path))
    LUT3D - Generated by Foundry::LUT
    ---------------------------------
    <BLANKLINE>
    Dimensions : 3
    Domain     : [[0 0 0]
                  [1 1 1]]
    Size       : (4, 4, 4, 3)

    Reading a 3D *Resolve* *.cube* *LUT* with comments:

    >>> path = os.path.join(
    ...     os.path.dirname(__file__), 'tests', 'resources', 'resolve_cube',
    ...     'Demo.cube')
    >>> print(read_LUT_ResolveCube(path))
    LUT2D - Demo
    ------------
    <BLANKLINE>
    Dimensions : 2
    Domain     : [[ 0.  0.  0.]
                  [ 3.  3.  3.]]
    Size       : (3, 3)
    Comment 01 : Comments can't go anywhere
    """

    title = re.sub('_|-|\.', ' ', os.path.splitext(os.path.basename(path))[0])
    domain = np.array([[0, 0, 0], [1, 1, 1]])
    dimensions = 3
    size = 2
    table = []
    comments = []

    def _parse_array(array):
        """
        Converts given string array to :class:`ndarray` class.
        """

        return np.array(list(map(DEFAULT_FLOAT_DTYPE, array)))

    with open(path) as cube_file:
        lines = cube_file.readlines()
        for line in lines:
            line = line.strip()

            if len(line) == 0:
                continue

            if line.startswith('#'):
                comments.append(line[1:].strip())
                continue

            tokens = line.split()
            if tokens[0] == 'TITLE':
                title = ' '.join(tokens[1:])[1:-1]
            elif tokens[0] == 'LUT_1D_INPUT_RANGE':
                domain = _parse_array(tokens[1:])
                domain = tstack((domain, domain, domain))
            elif tokens[0] == 'LUT_3D_INPUT_RANGE':
                domain = _parse_array(tokens[1:])
                domain = tstack((domain, domain, domain))
            elif tokens[0] == 'LUT_1D_SIZE':
                dimensions = 2
                size = np.int_(tokens[1])
            elif tokens[0] == 'LUT_3D_SIZE':
                dimensions = 3
                size = np.int_(tokens[1])
            else:
                table.append(_parse_array(tokens))

    table = np.asarray(table)
    if dimensions == 2:
        return LUT2D(
            table,
            title,
            domain,
            comments=comments)
    elif dimensions == 3:
        # The lines of table data shall be in ascending index order,
        # with the first component index (Red) changing most rapidly,
        # and the last component index (Blue) changing least rapidly.
        table = table.reshape((size, size, size, 3), order='F')

        return LUT3D(
            table,
            title,
            domain,
            comments=comments)


def write_LUT_ResolveCube(LUT, path, decimals=7):
    """
    Writes given *LUT* to given  *Resolve* *.cube* *LUT* file.

    Parameters
    ----------
    LUT : LUT1D or LUT2D or LUT3D
        :class:`LUT1D`, :class:`LUT2D` or :class:`LUT3D` class instance to
        write at given path.
    path : unicode
        *LUT* path.
    decimals : int, optional
        Formatting decimals.

    Returns
    -------
    bool
        Definition success.

    References
    ----------
    :cite:`Chamberlain2015`

    Examples
    --------
    Writing a 2D *Iridas* *.cube* *LUT*:

    >>> LUT = LUT2D(
    ...     LUT2D.linear_table(16) ** (1 / 2.2),
    ...     'My LUT',
    ...     np.array([[-0.1, -0.2, -0.4], [1.5, 3.0, 6.0]]),
    ...     comments=['A first comment.', 'A second comment.'])
    >>> write_LUT_IridasCube(LUT, 'My_LUT.cube')  # doctest: +SKIP

    Writing a 3D *Iridas* *.cube* *LUT*:

    >>> LUT = LUT3D(
    ...     LUT3D.linear_table(16) ** (1 / 2.2),
    ...     'My LUT',
    ...     np.array([[-0.1, -0.2, -0.4], [1.5, 3.0, 6.0]]),
    ...     comments=['A first comment.', 'A second comment.'])
    >>> write_LUT_IridasCube(LUT, 'My_LUT.cube')  # doctest: +SKIP
    """

    if isinstance(LUT, LUT1D):
        LUT = LUT.as_LUT2D()

    is_2D = isinstance(LUT, LUT2D)

    size = LUT.size
    if is_2D:
        assert 2 <= size <= 65536, '"LUT" size must be in domain [2, 65536]!'
    else:
        assert 2 <= size <= 256, '"LUT" size must be in domain [2, 256]!'

    def _format_array(array):
        """
        Formats given array as a *Resolve* *.cube* data row.
        """

        return '{1:0.{0}f} {2:0.{0}f} {3:0.{0}f}'.format(decimals, *array)

    def _format_tuple(array):
        """
        Formats given array as space separated values to *decimals* precison.
        """

        return '{1:0.{0}f} {2:0.{0}f}'.format(decimals, *array)

    with open(path, 'w') as cube_file:
        cube_file.write('TITLE "{0}"\n'.format(LUT.name))

        if LUT.comments:
            for comment in LUT.comments:
                cube_file.write('# {0}\n'.format(comment))

        cube_file.write('{0} {1}\n'.format('LUT_1D_SIZE' if is_2D else
                                           'LUT_3D_SIZE', LUT.table.shape[0]))
        default_domain = np.array([[0, 0, 0], [1, 1, 1]])

        if not is_2D:
            table = LUT.table.reshape((-1, 3), order='F')
            if not np.array_equal(LUT.domain, default_domain):
                cube_file.write('LUT_3D_INPUT_RANGE {0}\n'.format(
                    _format_tuple([LUT.domain[0][0], LUT.domain[1][0]])))
        else:
            table = LUT.table
            if not np.array_equal(LUT.domain, default_domain):
                cube_file.write('LUT_1D_INPUT_RANGE {0}\n'.format(
                    _format_tuple([LUT.domain[0][0], LUT.domain[1][0]])))

        for row in table:
            cube_file.write('{0}\n'.format(_format_array(row)))

    return True
